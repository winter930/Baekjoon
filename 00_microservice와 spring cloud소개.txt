2010대 이후 cloud native를 통한 시스템 구축(anti-fragile)
->로컬환경에서 클라우드환경
->확장성과 안정성
->지속적인 개선을 하더라도 탄력적으로 운영가능
-> devops
-> 다른 환경보다 시스템변화가 적고 비용이 적다

anti-fragile 특징
-auto scaling (자동 확장성)
최소 인스턴스를 설정 후 필요시 늘림(최대 사이즈도 정해짐)

-microservices
클라우드 네이티브 아키텍쳐 핵심
전체 서비스를 구축하고 있는 개별적인 모듈이나 기능을 독립적으로 개발, 배포, 운영할 수 있도록 세분화

-chaos enginnering
시스템이 예상하지 못한 상황에서도 견디고 신뢰성을 유지
변동, 불확실성에서 안정적인 서비스를 제공

-continuous deployments
많은 마이크로시스템을 일일이 빌드, 배포 하는 과정이 작업로드가 길어짐 -> 자동화된 시스템을 구축, 다음 단계로 넘어가는 과정을 파이프 라인으로 연결
작은 변화, 전체적인 시스템 업그레이드 작업에서 빠르게 적용가능
개발-통합-테스트-배포-모니터링-피드백
ci/cd(continuous integration / continuous deployments)


--------------------------------------------------------------------------------------------------------


클라우드 네이티브 아키텍처 특징
-확장 가능한 아키텍처 -> 더 많은 사용자 요청을 처리
시스템의 수평적 확정에 유연
확장된 서버로 시스템의 부하 분산, 가용성 보장
시스템 or 애플리케이션 단위의 패키지(컨테이너 기반 패키지)
모니터링

시스템 확장 scale
scale up - 하드웨어의 사양을 높이는 작업
scale out - 같은 사양의 서버(인스턴스)를 여러 대 배치 -> 더 많은 사용자의 요청 처리 가능
위의 방법은 비용이 많이 든다 but 클라우드 서비스를 제공해주는 업체에 가상의 서버, 가상의 스토리지, 가상의 네트워크 등을 빌려 사용, 사용하지 않는 경우 반납하여 비용 절약
가상 서버 기술이 중요


-탄력적 아키텍처
분리된 서비스 생성-통합-배포, 비즈니스 환경 변화에 대응 시간 단축
분활 된 서비스 구조
전체 애플리케이션을 구성하는 도메인의 특성에 따라 경계를 잘 구분하고 이에 맞게 서비스를 개발해야 함

무상태 통신 프로토콜
종속성 최소화, 상태를 갖지 않는 서비스를 제공하려고 노력해야 함

서비스의 추가와 삭제 자동으로 감지
마이크로서비스들은 배포될 때 자신들의 위치를 어디에 있는지 등록(디스커버리 서비스)
타 서비스들이 해당 서비스를 검색하고 사용 가능하게 함

변경된 서비스 요청에 따라 사용자 요청 처리(동적처리)


-장애 격리
특정 서비스에 오류가 발생해도 다른 서비스에 영향을 주지 않음


--------------------------------------------------------------------------------------------------------

클라우드 네이티브 어플리케이션 조건(중요!!)
-마이크로서비스
-ci/cd  (자동 통합, 빌드, 테스트, 배포)
-devops (위 과정을 반복해주는 것)
-컨테이너 가상화


ci/cd
지속적인 통합 - 여러 사람이 개발하는 것을 통합, 통합된 코드를 빌드
jenkins, team ci, travis ci 등이 있다.
깃과 연결하여 충돌 확인 가능

지속적인 배포 - 지속적 전달과 배포
패키지화된 결과물을 실행환경에 배포하는 것을 수동으로 하면 전달 자동으로 해주면 배포
기존 시스템과 함께 운영을 통해 이질감 감소시키는 것이 목표
카나리 배포, 블루그린 배포이 있다.


DevOps
개발(구현, 계획, 패키지, verify), 운영(릴리즈, configure, 모니터링)이 합해진 용어
고객의 요구사항을 빠르게 파악 후 빠르게 반영하는 것을 목표로 하고 만족스러운 결과물을 내기 위함
일반적인 과정 = 도메인분석 - 시스템설계 - 구현 - 테스트 - 배포
자주 테스트, 피드백, 업데이트하는 과정을 거쳐 개발일정이 완료된 때까지 지속적으로 반복


컨테이너 가상화
로컬환경에서 운영하고 유지하던 시스템을 클라우드 환경으로 이전
적은 리소스 사용
전통적 방식 - 운영체제 위에 애플리케이션
가상화 배포 - 하이퍼바이저(hypervisor)를 통해 각각의 버츄얼 머신 사용, 각 가상머신 환경에서 개별 운영체제 있음, 호스트 운영체제에 많은 부하를 주고 시스템 확장에 한계가 있음
컨테이너 배포 - 컨테이너 서비스를 사용, 라이브러리와 리소스 공유, 개별 컨테이너에 필요한 것만 개별적으로 설치


--------------------------------------------------------------------------------------------------------

12 factors
코드 통합
버전 제어가 목적, 형상관리를 위해 코드를 한 곳에서 배포
코드의 통일적인 관리

종속성의 배제
마이크로서비스는 자체 종속성을 가지고 있어 전체 시스템에 영향을 주지 않으면서 변경 가능해야 한다.

환경 설정의 외부 관리
구성 관리를 통해서 마이크로서비스에 필요한 작업을 제어

백업 서비스의 분리
데이터 베이스 이용
상호 의존을 없앰

개발 환경과 테스트 운영 환경 분리
롤백
자동화된 시스템

stateless processes
독립성
필요 자원이 있다면 캐쉬 등 데이터 저장소를 통해 외부와 데이터 교환

포트 바인딩
자체 포트에서 자체 포함된 기능이 있어야 한다.
다른 마이크로서비스와 격리가 가능

동시성
많은 수의 서비스를 복사해 여러 인스턴스에서 사용

서비스의 올바른 상태 유지
삭제 가능해야하며 확장성 기회를 높여야 하며 정상적으로 종료가 되어야 한다.

개발과 운영 환경의 분리

로그
이벤트를 정리, 어플리케이션이 작동하지 않더라도 작동해야 함
모니터링 도구를 사용할 수도 있음(elk, 에즈웜)

관리 프로세스
리소스가 현재 어떻게 쓰이는지 파악하기 위한 도구가 필요
데이터 분석 기능 등

+ 3
api first
api 형태로 서비스 제공

telemetry
수치화와 시각화를 통한 관리

authentication and authorization
인증


--------------------------------------------------------------------------------------------------------


시스템을 구축하고 운영하는 방식 2가지
모노리스(monolith) 정의와 특징
어플리케이션의 개발함에 있어 모든 요소를 하나의 큰 소프트웨어 안에 포함시키는 방법
데이터베이스, 비지니스 로직 등 모든 서비스의 내용들이 하나의 어플리케이션에서 유기적으로 연결되어 작동
서로 의존성을 가지며 패키지화 됨

모든 업무 로직이 하나의 애플리케이션 형태로 패키지 되어 서비스
애플리케이션에서 사용하는 데이터가 한곳에 모여 참조되어 서비스 되는 형태
시스템 일부만 수정해도 전체를 다시 빌드, 배포해야 함(전체 패키지이기 때문)


마이크로서비스 정의와 특징
어플리케이션을 구성하는 각각의 구성요소 및 서비스 내용을 분리해서 개발 및 운영
유지보수나 변경사항을 적용하기 쉽다.
독립적으로 배포 가능
어플리케이션 전체가 다운타임(사용할 수 없는 시간)이 되는 현상을 없앨 수 있다.

함께 작동하는 작은 규모의 서비스들
http를 이용하여 리소스 api에 통신할 수 있는 작은 규모의 여러 서비스들의 묶음
완전 자동화된 시스템
최소한의 중앙집중식 관리, 서로 다른 프로그래밍과 다른 데이터 스토리지를 사용 가능(상황과 기능에 맞는 언어를 사용)

작은 서비스
경계 구분 잘해야 함
restful api
설정관리는 외부 시스템으로, 환경 설정 데이터는 외부에서 사용
클라우드 네이티브
동적인 스케일 업 다운
ci/cd
시각화를 통한 관리


마이크로서비스로 변경 및 도입시 고려할 점
변화의 정도
시스템과 기능들이 독립 운영이 가능한가
독립적인 확장(및 유지 보수)이 가능한가
독립적인 오류
외부 종속성과 상호작용을 최소화 및 단순화
다양한 언어나 프로그램을 사용할 수 있는 환경인가(polyglot 기술)


--------------------------------------------------------------------------------------------------------

SOA(service oriented architecture)와 MSA 차이점
soa
-재사용을 통한 비용 절감(서비스 공유 최대화)
-공통의 서비스를 ESB(enterprise Service Bus), WSDL, UDDI 등의 '미들웨어'에 모아 사업 측면에서 공통 서비스 형식으로 서비스 제공, web service or soap

msa
-서비스 간의 결합도를 낮추어 변화에 능동적으로 대응(서비스 공유 최소화)
-각 독립된 서비스가 노출된 REST api를 사용, restful

cf> restful, rest api란?
level 0 : 웹서비스 상태로 제공하기 위해 url만 맵핑한 상태

level 1 : 의미있는 적절한 url로 표현, 적절한 패턴은 있지만 http의 메소드에 서비스별로 구분하진 않음 = 서비스의 형태와 작업에 맞춰서 http 메소드를 지정하지 않음

level 2 : level 1 + HTTP methods
리소스의 상태를 구분
읽기 용도 : get
새로운 리소스 추가 : post
기존의 리소스를 변경 : put
리소스를 삭제 : delete

level 3 : level 2 + HATEOAS
데이터와 다음 가능한 액션에 대한 상태 정보를 넘겨줌

주요 특징 및 주의 점
-소비자 중심 설계
-HTTP의 장점을 이용
-request methods - get,post,put,delete
-response status
200, 201 - 정상처리
404(not found), 400, 401 - 클라이언트 오류
500번대 - 서버 오류

-url에 보안 관련 정보가 없어야함
복수형태의 url값을 사용해야함
ex) prefer/users to / user => prefer/users/1 to /user/1

-명사형태(사용자에게 직관적)
예외처리(일괄적인 엔드포인트 사용)


--------------------------------------------------------------------------------------------------------

MSA 표준 구성요소
사진 참조

클라이언트 - 모바일, 브라우저 앱 등
api - 게이트웨이
서비스 라우터
서비스 디스커버리 - 어디에 서비스가 저장되어 있는가 찾아줌
로드 Balancing - 어떤 서비스로 보낼지 결정(서비스, 인스턴스)
컨테이너 Management(서비스가 있는 곳)
CI/CD - 외부 시스템을 배포하기 위한 자동화
텔레메트리 - 모니터링, 진단


service Mesh(계층으로 보면 될듯)
서비스 라우터, 서비스 디스커버리, 로드 Balancing 등
설정, 라우팅, 인증, 암호화 도 있음
추상화, 신뢰성을 높임 
서비스간의 통신과 관련된 기능을 자동화
미들웨어 역할


CNCF(클라우드 네이티브 컴퓨팅 파운데이션)
시스템 가이드
게이트웨이, 런타임(운영 및 관리), 프레임워크, 서비스 메쉬, 자동화(자동 빌드 및 배포), 텔레메트리(모니터링, 시각화도구), 백업 서비스 등이 있다.


--------------------------------------------------------------------------------------------------------

spring cloud
환경설정 관리, 프록시 등을 쉽게 관리할 수 있다.
스프링 부트와 스프링 클라우드의 버전 확인 중요
config - 설정관리 기능
netflix - 외부 모니터링
security
sleuth
starters
gateway - 로드 밸런싱
openfeign



--------------------------------------------------------------------------------------------------------



--------------------------------------------------------------------------------------------------------


